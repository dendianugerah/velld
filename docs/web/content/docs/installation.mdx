---
title: Installation
description: Get started with Velld in minutes
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

# Installation

Velld is designed to be simple to install and run. Choose the installation method that works best for you.

## Prerequisites

Before you begin, ensure you have:

- **Docker** and **Docker Compose** installed
- At least **512MB RAM** and **1GB disk space**
- A database you want to backup (PostgreSQL, MySQL, MSSQL, MongoDB, or Redis)

<Callout type="info">
  Velld only installs the database clients you need. This keeps the Docker image lightweight and secure.
</Callout>

## Quick Start

**Fastest way** - Pull and run pre-built images directly (no git clone needed):

```bash
# Pull images
docker pull ghcr.io/dendianugerah/velld/api:latest
docker pull ghcr.io/dendianugerah/velld/web:latest

# Create .env file
cat > .env << EOF
NEXT_PUBLIC_API_URL=http://localhost:8080
JWT_SECRET=$(openssl rand -hex 32)
ENCRYPTION_KEY=$(openssl rand -hex 32)
ADMIN_USERNAME_CREDENTIAL=admin
ADMIN_PASSWORD_CREDENTIAL=changeme
ALLOW_REGISTER=true
EOF

# Run API
docker run -d \
  --name velld-api \
  -p 8080:8080 \
  --env-file .env \
  -v velld-data:/app/data \
  -v velld-backups:/app/backups \
  ghcr.io/dendianugerah/velld/api:latest

# Run Web
docker run -d \
  --name velld-web \
  -p 3000:3000 \
  -e NEXT_PUBLIC_API_URL=http://localhost:8080 \
  -e ALLOW_REGISTER=true \
  ghcr.io/dendianugerah/velld/web:latest
```

<Callout type="warning">
  **Important:** The data directory has changed from `/app/internal/database` to `/app/data`.
</Callout>

Open [http://localhost:3000](http://localhost:3000) in your browser.

---

## Using Docker Compose

If you prefer docker-compose:

```bash
git clone https://github.com/dendianugerah/velld.git
cd velld
cp .env.example .env
docker compose -f docker-compose.prebuilt.yml up -d
```

---

## Build from Source

If you want to build the images yourself:

```bash
git clone https://github.com/dendianugerah/velld.git
cd velld
cp .env.example .env
docker compose up -d
```

---

## Database-Specific Installation

Choose only the database client you need to keep your installation lightweight:

<Tabs items={['PostgreSQL', 'MySQL', 'MSSQL', 'MongoDB']}>
  <Tab value="PostgreSQL">
    ### PostgreSQL Only

    **1. Create a custom Dockerfile**

    Create `apps/api/Dockerfile.postgres`:

    ```dockerfile
    FROM golang:1.24-alpine AS builder

    WORKDIR /app

    RUN apk add --no-cache gcc musl-dev

    COPY go.mod go.sum ./
    RUN go mod download

    COPY . .

    RUN CGO_ENABLED=1 GOOS=linux go build -o main cmd/api-server/main.go

    FROM alpine:latest

    # Install only PostgreSQL client
    RUN apk add --no-cache \
        sqlite-libs \
        postgresql-client

    WORKDIR /app

    COPY --from=builder /app/main .
    COPY --from=builder /app/internal/database ./internal/database

    EXPOSE 8080

    CMD ["./main"]
    ```

    **2. Update docker-compose.yml**

    ```yaml
    services:
      api:
        build:
          context: ./apps/api
          dockerfile: Dockerfile.postgres  # Use PostgreSQL-only Dockerfile
        ports:
          - "8080:8080"
        env_file:
          - .env
        volumes:
          - api_data:/app/data
          - backup_data:/app/backups
        restart: unless-stopped

      web:
        build:
          context: ./apps/web
          dockerfile: Dockerfile
        ports:
          - "3000:3000"
        environment:
          NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
          ALLOW_REGISTER: ${ALLOW_REGISTER}
        depends_on:
          - api
        restart: unless-stopped

    volumes:
      api_data:
      backup_data:
    ```

    **3. Start the services**

    ```bash
    docker compose up -d
    ```

    <Callout type="success">
      Your PostgreSQL-only installation is now running! Image size: ~50MB lighter.
    </Callout>
  </Tab>

  <Tab value="MySQL">
    ### MySQL Only

    **1. Create a custom Dockerfile**

    Create `apps/api/Dockerfile.mysql`:

    ```dockerfile
    FROM golang:1.24-alpine AS builder

    WORKDIR /app

    RUN apk add --no-cache gcc musl-dev

    COPY go.mod go.sum ./
    RUN go mod download

    COPY . .

    RUN CGO_ENABLED=1 GOOS=linux go build -o main cmd/api-server/main.go

    FROM alpine:latest

    # Install only MySQL client
    RUN apk add --no-cache \
        sqlite-libs \
        mysql-client

    WORKDIR /app

    COPY --from=builder /app/main .
    COPY --from=builder /app/internal/database ./internal/database

    EXPOSE 8080

    CMD ["./main"]
    ```

    **2. Update docker-compose.yml**

    ```yaml
    services:
      api:
        build:
          context: ./apps/api
          dockerfile: Dockerfile.mysql  # Use MySQL-only Dockerfile
        ports:
          - "8080:8080"
        env_file:
          - .env
        volumes:
          - api_data:/app/data
          - backup_data:/app/backups
        restart: unless-stopped

      web:
        build:
          context: ./apps/web
          dockerfile: Dockerfile
        ports:
          - "3000:3000"
        environment:
          NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
          ALLOW_REGISTER: ${ALLOW_REGISTER}
        depends_on:
          - api
        restart: unless-stopped

    volumes:
      api_data:
      backup_data:
    ```

    **3. Start the services**

    ```bash
    docker compose up -d
    ```

    <Callout type="success">
      Your MySQL-only installation is now running! Image size: ~45MB lighter.
    </Callout>
  </Tab>

  <Tab value="MongoDB">
    ### MongoDB Only

    **1. Create a custom Dockerfile**

    Create `apps/api/Dockerfile.mongo`:

    ```dockerfile
    FROM golang:1.24-alpine AS builder

    WORKDIR /app

    RUN apk add --no-cache gcc musl-dev

    COPY go.mod go.sum ./
    RUN go mod download

    COPY . .

    RUN CGO_ENABLED=1 GOOS=linux go build -o main cmd/api-server/main.go

    FROM alpine:latest

    # Install only MongoDB tools
    RUN apk add --no-cache \
        sqlite-libs \
        mongodb-tools

    WORKDIR /app

    COPY --from=builder /app/main .
    COPY --from=builder /app/internal/database ./internal/database

    EXPOSE 8080

    CMD ["./main"]
    ```

    **2. Update docker-compose.yml**

    ```yaml
    services:
      api:
        build:
          context: ./apps/api
          dockerfile: Dockerfile.mongo  # Use MongoDB-only Dockerfile
        ports:
          - "8080:8080"
        env_file:
          - .env
        volumes:
          - api_data:/app/data
          - backup_data:/app/backups
        restart: unless-stopped

      web:
        build:
          context: ./apps/web
          dockerfile: Dockerfile
        ports:
          - "3000:3000"
        environment:
          NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
          ALLOW_REGISTER: ${ALLOW_REGISTER}
        depends_on:
          - api
        restart: unless-stopped

    volumes:
      api_data:
      backup_data:
    ```

    **3. Start the services**

    ```bash
    docker compose up -d
    ```

    <Callout type="success">
      Your MongoDB-only installation is now running! Image size: ~60MB lighter.
    </Callout>
  </Tab>

  <Tab value="MSSQL">
    ### MSSQL Only

    **1. Create a custom Dockerfile**

    Create `apps/api/Dockerfile.mssql`:

    ```dockerfile
    FROM golang:1.24-alpine AS builder

    WORKDIR /app

    RUN apk add --no-cache gcc musl-dev

    COPY go.mod go.sum ./
    RUN go mod download

    COPY . .

    RUN CGO_ENABLED=1 GOOS=linux go build -o main cmd/api-server/main.go

    FROM alpine:latest

    # Install MSSQL tools
    RUN apk add --no-cache \
        sqlite-libs \
        freetds \
        curl \
        gnupg

    # Install Microsoft SQL Server Tools
    RUN curl -O https://download.microsoft.com/download/b/9/f/b9f3cce4-3925-46d4-9f46-da08869c6486/msodbcsql18_18.1.1.1-1_amd64.apk && \
        curl -O https://download.microsoft.com/download/b/9/f/b9f3cce4-3925-46d4-9f46-da08869c6486/mssql-tools18_18.1.1.1-1_amd64.apk && \
        apk add --allow-untrusted msodbcsql18_18.1.1.1-1_amd64.apk && \
        apk add --allow-untrusted mssql-tools18_18.1.1.1-1_amd64.apk && \
        rm -f msodbcsql18_18.1.1.1-1_amd64.apk mssql-tools18_18.1.1.1-1_amd64.apk && \
        apk del curl gnupg

    ENV PATH="${PATH}:/opt/mssql-tools18/bin"

    WORKDIR /app

    COPY --from=builder /app/main .
    COPY --from=builder /app/internal/database ./internal/database

    EXPOSE 8080

    CMD ["./main"]
    ```

    **2. Create a custom docker-compose.yml**

    Create `docker-compose.mssql.yml`:

    ```yaml
    services:
      api:
        build:
          context: ./apps/api
          dockerfile: Dockerfile.mssql  # Use MSSQL-only Dockerfile
        ports:
          - "8080:8080"
        volumes:
          - api_data:/app/data
          - backup_data:/app/backups
        environment:
          JWT_SECRET: ${JWT_SECRET}
          ENCRYPTION_KEY: ${ENCRYPTION_KEY}
          ADMIN_USERNAME_CREDENTIAL: ${ADMIN_USERNAME_CREDENTIAL}
          ADMIN_PASSWORD_CREDENTIAL: ${ADMIN_PASSWORD_CREDENTIAL}
          ALLOW_REGISTER: ${ALLOW_REGISTER}
        restart: unless-stopped

      web:
        build:
          context: ./apps/web
          dockerfile: Dockerfile
        ports:
          - "3000:3000"
        environment:
          NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}
          ALLOW_REGISTER: ${ALLOW_REGISTER}
        depends_on:
          - api
        restart: unless-stopped

    volumes:
      api_data:
      backup_data:
    ```

    **3. Start the services**

    ```bash
    docker compose -f docker-compose.mssql.yml up -d
    ```

    <Callout type="success">
      Your MSSQL-only installation is now running! Includes SQL Server command-line tools.
    </Callout>
  </Tab>
</Tabs>

---

## Environment Configuration

Create a `.env` file in the project root:

```bash
cp .env.example .env
```

### Required Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `NEXT_PUBLIC_API_URL` | API server URL (must be accessible from browser) | `http://localhost:8080` |
| `JWT_SECRET` | JWT signing key - generate with `openssl rand -hex 32` | 64 hex characters |
| `ENCRYPTION_KEY` | Database credential encryption key - generate with `openssl rand -hex 32` | 64 hex characters |

<Callout type="error">
  **Production:** Always set `JWT_SECRET` and `ENCRYPTION_KEY` manually. While they auto-generate if missing, changing keys will log out users and break database connections.
  
  ```bash
  # Generate secure keys
  openssl rand -hex 32  # Run twice, once for each
  ```
</Callout>

### Authentication

| Variable | Description | Default |
|----------|-------------|---------|
| `ALLOW_REGISTER` | Enable public registration | `true` |
| `ADMIN_USERNAME_CREDENTIAL` | Admin username (required if `ALLOW_REGISTER=false`) | - |
| `ADMIN_PASSWORD_CREDENTIAL` | Admin password (required if `ALLOW_REGISTER=false`) | - |

### Optional: Email Notifications

Configure SMTP to get notified when backups fail. You can configure these either:
- **Via UI**: Go to Settings â†’ Notifications (recommended for most users)
- **Via Environment Variables**: Set below variables (useful for Docker/Kubernetes deployments)

When configured via environment variables, these settings become **read-only in the UI** and cannot be changed from the web interface.

| Variable | Description | Default |
|----------|-------------|---------|
| `SMTP_HOST` | SMTP server hostname | - |
| `SMTP_PORT` | SMTP port | `587` |
| `SMTP_USER` | SMTP username/email | - |
| `SMTP_PASSWORD` | SMTP password (use [App Password](https://support.google.com/accounts/answer/185833) for Gmail) | - |
| `SMTP_FROM` | From address | - |

### Advanced

| Variable | Description | Default |
|----------|-------------|---------|
| `DB_PATH` | Path to Velld's SQLite database | `/app/data/velld.db` |
| `PORT` | API server port | `8080` |

<Callout type="info">
  **Data Persistence:** Ensure `/app/data` is mounted as a volume to persist your database.
</Callout>

---

## Verify Installation

Once the services are running, verify everything works:

1. **Check service status**
   ```bash
   docker compose ps
   ```

2. **View logs**
   ```bash
   docker compose logs -f
   ```

3. **Access the web interface**
   
   Open [http://localhost:3000](http://localhost:3000) in your browser.

4. **Create your account**
   
   Sign up with your email and start managing backups!

---

## Updating Velld

To update to the latest version:

```bash
# Pull the latest changes
git pull origin main

# Rebuild and restart
docker compose down
docker compose up -d --build
```

---

## Troubleshooting

### Services won't start

```bash
# Check logs for errors
docker compose logs api
docker compose logs web

# Ensure ports 3000 and 8080 are available
lsof -i :3000
lsof -i :8080
```

### Database connection fails

- Ensure your database is accessible from the Docker container
- Use `host.docker.internal` instead of `localhost` to connect to databases on your host machine
- Check firewall rules

### Backup fails

- Verify the database client is installed (check which Dockerfile you're using)
- Test connection credentials manually
- Check backup directory permissions

---
